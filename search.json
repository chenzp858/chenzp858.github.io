[{"title":"Hello World","url":"/post/4a17b156.html","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ npx hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ npx hexo server\n\nMore info: Server\nGenerate static files$ npx hexo generate\n\nMore info: Generating\nDeploy to remote sites$ npx hexo deploy\n\nMore info: Deployment\n"},{"title":"Cesium","url":"/post/361b4ed7.html","content":"Cesium学习笔记1.Cesium坐标转换及源码分析\n1.1Cesium坐标系问题​         Cesium坐标系主要分为地理坐标系和笛卡尔坐标系（地理坐标系，地心地固坐标系，东-北-上局部坐标系和屏幕坐标系）\n1.1.1WGS84 坐标系（地理坐标系）格式：[经度，纬度，高度]       经度（Longitude）：-180° 到 180°，东经为正。      纬度（Latitude）：-90° 到 90°，北纬为正。      高度（Height）：椭球体高度（米），基于 WGS84 椭球面。核心用途：人类可读的地理位置输入（如 GPS 坐标、地图标记）\n  WGS84 高度是相对于椭球面的，如需获取真实地面高度，需使用地形数据。\n1.1.2地心地固坐标系（ECEF）（重要知识点）​       地心地固坐标系（Earth-Centered, Earth-Fixed，简称ECEF）简称地心坐标系，是一种以地心为原点的地固坐标系（也称地球坐标系），是一种笛卡儿坐标系。原点 O (0,0,0)为地球质心，z 轴与地轴平行指向北极点，x 轴指向本初子午线与赤道的交点，y 轴垂直于xOz平面(即东经90度与赤道的交点)构成右手坐标系。\n\n原点：地球质心。\n轴方向\n\nX 轴：赤道与本初子午线（0° 经度）的交点。\n\nZ 轴：地球自转轴（指向北极）。\n\nY 轴：与 X、Z 轴构成右手坐标系（东经 90° 方向）。1\n\n\n\n\n经纬度要转为弧度进行计算，它的本质就是弧度\n\n将地理坐标（经度λ、纬度φ、高度h）转换为ECEF笛卡尔坐标（X, Y, Z）的公式如下：\nX &#x3D; (N + h) * cosφ * cosλ\nY &#x3D; (N + h) * cosφ * sinλ\nZ &#x3D; (N * (1 - e²) + h) * sinφ\n经纬度要转为弧.度进行计算，它的本质就是弧度\nX &#x3D; (N + h) * cosφ * cosλY &#x3D; (N + h) * cosφ * sinλZ &#x3D; (N * (1 - e²) + h) * sinφ\n*卯酉圈曲率半径 N*\n\n定义：在给定纬度 ϕϕ 处，垂直于子午面的曲率半径（即东西方向的曲率半径）。\n\n计算公式：\n物理意义：\n\n在赤道（ϕ&#x3D;0°ϕ&#x3D;0°）时，N&#x3D;aN&#x3D;a（最大）。\n在极点（ϕ&#x3D;90°ϕ&#x3D;90°）时，N&#x3D;a1−e2N&#x3D;1−e2a（最小）。\n\n\n作用：用于计算ECEF坐标的 X,Y,ZX,Y,Z 分量。\n\n\n1.1.3四元数\n用途：表示 3D 旋转，避免万向节锁问题，且计算效率高。\n\n结构：包含 4 个分量 [x, y, z, w]，通常表示绕某个轴的旋转。\n\n公式：\n\n$$q&#x3D;[x,y,z,w]&#x3D;cos(θ&#x2F;2)+(i⋅x+j⋅y+k⋅z)sin(θ&#x2F;2)$$\n其中，θ 是旋转角度，(x,y,z) 是旋转轴。\n\n紧凑性：仅需 4 个数值，内存占用小于矩阵。\n\n插值平滑：适合球面线性插值（SLERP），用于动画过渡。\n\n归一化：四元数必须归一化（长度为 1）才能正确表示旋转。\n\n//创建四元数const axis = new Cesiun.Cartesian3(0,1,0)//定义Y轴const angle = Cesium.Math.toRadians(90); // 弧度const quaternion = Cesium.Quaternion.fromAxisAngle(axis, angle);// 应用四元数到实体方向entity.orientation = quaternion;\n\n1.1.4webgl的坐标系统\n在 Cesium（基于WebGL）中，视口（viewport）的坐标系遵循 WebGL 标准，即：(0, 0) 表示屏幕的左下角，x 向右增加，y 向上增加。这一点与浏览器DOM的坐标系（左上角为 (0, 0)）不同，需要特别注意。\nconst viewer = new Cesium.Viewer(&quot;cesiumContainer&quot;);const scene = viewer.scene;const passState = scene._view.passState;// 保存原始视口const originalViewport = passState.viewport;// 临时修改视口（渲染到左上角 400x300 区域）passState.viewport = new Cesium.BoundingRectangle(0, canvas.height - 300, 400, 300);// 执行自定义渲染（如绘制特殊效果）// ...// 恢复原始视口passState.viewport = originalViewport;\n\n\n1. Cesium&#x2F;WebGL 视口坐标系详解\n\n\n属性\n方向\n范围\n示例（屏幕分辨率 1920x1080）\n\n\n\nx\n水平（→）\n0（左边界）→ canvas.width\nx=100 表示距离左侧 100 像素\n\n\ny\n垂直（↑）\n0（下边界）→ canvas.height\ny=200 表示距离底部 200 像素\n\n\nwidth\n宽度\n视口的横向像素数\nwidth=800 表示视口宽 800 像素\n\n\nheight\n高度\n视口的纵向像素数\nheight=600 表示视口高 600 像素\n\n\n1.1.5 2D的平移缩放\n2 Cesium ScreenSpaceEventHandle**Cesium.defined()**是 Cesium 中一个常用的实用函数，用于检查变量是否已定义且不为 null 或 undefined。\nCesium.defined(value)\n\n​\t注册这个实用类\nnew Cesium.ScreenSpaceEventHandler(element)\n\nsetInputAction(action, type, modifier)\n设置输入事件的处理函数。\n\n\n\n参数\n类型\n描述\n\n\n\naction\n各种事件回调\n事件处理函数\n\n\ntype\nScreenSpaceEventType\n输入事件类型\n\n\nmodifier\nKeyboardEventModifier\n修饰键\n\n\n事件类型对照表\n\n\n\n事件类型\n描述\n回调参数\n\n\n\nLEFT_CLICK\n左键点击\nPositionedEvent\n\n\nMOUSE_MOVE\n鼠标移动\nMotionEvent\n\n\nWHEEL\n滚轮滚动\ndelta (数值)\n\n\nPINCH_START\n双指开始\nTwoPointEvent\n\n\nPINCH_MOVE\n双指移动\nTwoPointMotionEvent\n\n\n3 Cesium.Camrea()camera.setView(&#123;  destination: Cesium.Cartesian3.fromDegrees(117.16, 34.21, 1500.0), // 经纬度 + 高度（米）  orientation: &#123;    heading: Cesium.Math.toRadians(0.0),   // 朝向正北    pitch: Cesium.Math.toRadians(-45.0),   // 向下看 45 度    roll: 0.0  &#125;&#125;);\n\ndestination: 摄像机目标点位置（Cartesian3）\n这个就是相机的View矩阵\norientation: 视角\n\nheading：绕地球垂直轴旋转（相当于左右转）\npitch：绕摄像机右方向旋转（相当于上下转）\nroll：绕摄像机前方向旋转（通常为 0）\n\n3.1 正交相机正交投影与相机位置，相当于给了一个空间，可以看物体的全貌。\nc\nCesium实现的具体过程\ncreateOrthCamera()&#123;    //初始化正交相机    const camera = new Cesium.Camera(viewer.scene)    //设置正交视锥体    camera.frustum = new Cesium.OrthographicOffCenterFrustum()     const [lon,lat] = this.config.lonLat    const center = Cesium.Cartesian3.fromDegrees(lon,lat,0)    //获取ENU变化矩阵    const enuMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);    const frustum = camera.frustum    const frustum = camera.frustum;    frustum.near = 0.01;    frustum.far = this.config.dimensions.z * 2;    frustum.left = -this.config.dimensions.x / 2;    frustum.right = this.config.dimensions.x / 2;    frustum.bottom = -this.config.dimensions.y / 2;    frustum.top = this.config.dimensions.y / 2;    //设置相机姿态    const dir = Cesium.Matrix4.getColumn(enuMatrix, 2, new Cesium.Cartesian3()); // Z轴向量    Cesium.Cartesian3.negate(dir, dir); // 向下    const up = Cesium.Matrix4.getColumn(enuMatrix, 1, new Cesium.Cartesian3()); // 北为上    const right = Cesium.Matrix4.getColumn(enuMatrix, 0, new Cesium.Cartesian3()); // 东为右    //设置相机的位置与朝向    const offset = Cesium.Cartesian3.multiplyByScalar(dir, -frustum.far, new Cesium.Cartesian3());    camera.position = Cesium.Cartesian3.add(center, offset, new Cesium.Cartesian3());    camera.direction = dir;    camera.up = up;    camera.right = right;    return camera;    &#125;\n\n\n\n4GLSL着色器语言（UV 坐标系，原点在左下角）4.1声明常量与变量、声明变量\n// 着色器语言定义一个整形常量int count = 10;// 定义一个浮点数变量num，并赋值10.0float num = 10.0;// 定义一个三维向量vec3vec3 direction = vec3(1.0,0.5,0.6);// 声明一个数据类型是布尔值的变量，并赋值为truebool lightBool = true;\n\n声明常量\n// 着色器语言定义一个整形常量const int count = 10;// 定义一个浮点数常量10.0const float count = 10.0;// 定义一个三维向量vec3常量,表示方向等量const vec3 direction = vec(1.0,0.5,0.6);\n\n4.2数据类型常见数据类型\n\n\nbool\n布尔值\n布尔变量值为true或false\n\n\n\nint\n整型数\n值为整数，比如0,1,2,3…\n\n\nfloat\n单精度浮点数\n浮点数用小数点表示，比如0.6,3.14,2.8\n\n\n矢量和向量\n\n\n关键字\n数据类型\n\n\n\nvec2\n二维向量，具有xy两个分量，分量是浮点数\n\n\nvec3\n三维向量 ，具有xyz三个分量，分量是浮点数\n\n\nvec4\n四维向量 ，具有xyzw四个分量，分量是浮点数\n\n\nivec2\n二维向量，分量是整型数\n\n\nivec3\n三维向量 ，分量是整型数\n\n\nivec4\n四维向量 ，分量是整型数\n\n\nbvec2\n二维向量，分量是布尔值bool\n\n\nbvec3\n三维向量 ，分量是布尔值bool\n\n\nbvec4\n四维向量 ，分量是布尔值bool\n\n\n访问获取向量分量\n\n\n向量vector\n访问\n\n\n\n第1个分量\nvector.x\n\n\n第2个分量\nvector.y\n\n\n第3个分量\nvector.z\n\n\n第4个分量\nvector.w\n\n\n// 声明一个三维向量，假设向量表示三维坐标中一个位置坐标vec3 pos = vec3(10.2,9.6,3.9);// 三维向量pos的x分量被改变，相当于在原来的基础上沿着x轴平移2.0pos.x = pos.x+2.0;// 直接改变三维向量的x分量，相当于把顶点的x坐标值直接设置为20.0pos.x = 20.0;\n\n// 声明一个三维向量变量，并赋值vec3 v3 = vec3(10.0,9.0,3.0);// 声明一个二维向量vec2 v2;// 提取向量v3的xy两个分量赋值给二维向量v2v2 = v3.xy;//v3.xy相等于vec2(10.0,9.0);// v3的x分量赋值给v2的x分量，v3的z分量赋值给v2的y分量v2 = v3.xz;//获得zx分量  v3.xz等价于vec2(10.0,3.0)v2 = v3.yz;//获得yz分量//获得zx分量 v3的z分量赋值给v2的x分量，v3的x分量赋值给v2的y分量v2 = v3.zx;\n\n\n\n矩阵注意行列对应关系，按照列的先后顺序，从上到下依次传入mat构造函数参数中。\n// 需要表示的矩阵// 1.1 1.2 1.3 1.4// 2.1 2.2 2.3 2.4// 3.1 3.2 3.3 3.4// 4.1 4.2 4.3 4.4mat4 matrix4 = mat4(1.1,2.1,3.1,4.1,1.2,2.2,3.2,4.2,1.3,2.3,3.3,4.3,1.4,2.4,3.4,4.4);\n\nmat4(2.0)写法快速创建一个4x4对角矩阵\nmat4 matrix4 = mat4(1.1,2.1,3.1,4.1,1.2,2.2,3.2,4.2,1.3,2.3,3.3,4.3,1.4,2.4,3.4,4.4);// 访问矩阵matrix4的第二列vec4 v4 = matrix4[1];//返回值vec4(1.2,2.2,3.2,4.2)// 访问矩阵matrix4的第三列第四行对应的元素float f = matrix4[2][3];//返回4.3\n\n4.3内置变量普通变量，着色器语言和javascript语言一样需要先声明后使用，所谓内置变量就是不用声明可以直接赋值，主要是为了实现特定的功能。\n\n\n\n内置变量\n含义\n值数据类型\n\n\n\ngl_PointSize\n点渲染模式，方形点区域渲染像素大小\nfloat\n\n\ngl_Position\n顶点位置坐标\nvec4\n\n\ngl_FragColor\n片元颜色值\nvec4\n\n\ngl_FragCoord\n片元坐标，单位像素\nvec2\n\n\ngl_PointCoord\n点渲染模式对应点像素坐标\nvec2\n\n\ngl_PointSize当WebGL执行绘制函数gl.drawArrays()绘制模式是点模式gl.POINTS的时候，顶点着色器语言main函数中才会用到内置变量gl_PointSize，使用内置变量gl_PointSize主要是用来设置顶点渲染出来的方形点像素大小。\nvoid main() &#123;  //给内置变量gl_PointSize赋值像素大小，注意值是浮点数  gl_PointSize=20.0;&#125;\n\ngl_FragColorgl_FragColor内置变量主要用来设置片元像素的颜色，出现的位置是片元着色器语言的main函数中。\n内置变量gl_FragColor的值是四维向量vec4(r,g,b,a),前三个参数表示片元像素颜色值RGB，第四个参数是片元像素透明度A，1.0表示不透明,0.0表示完全透明\nvoid main() &#123;    // 片元沿着x方向渐变    gl_FragColor = vec4(gl_FragCoord.x/500.0*1.0,1.0,0.0,1.0);  &#125;\n\n\n\n5Cesium.PostProcessStageCesium.PostProcessStage 允许你通过 GLSL 片元着色器对渲染后的图像做进一步处理。\nconst myStage = new Cesium.PostProcessStage(&#123;  name: &#x27;myCustomStage&#x27;,  fragmentShader: &#x27;uniform sampler2D colorTexture; varying vec2 v_textureCoordinates; void main() &#123; gl_FragColor = texture2D(colorTexture, v_textureCoordinates); &#125;&#x27;,  uniforms: &#123;    myParam: 0.5  &#125;&#125;);// 接收插值后的纹理坐标varying vec2 v_TexCoord;// 纹理图片像素数据uniform sampler2D u_Sampler;void main() &#123;  // 采集纹素，逐片元赋值像素值  gl_FragColor = texture2D(u_Sampler,v_TexCoord);&#125;\n\n\n\n\n参数名\n类型\n说明\n\n\n\nname\nString\n后处理阶段的名字，必须唯一。\n\n\nfragmentShader\nString\nGLSL 片元着色器代码，用于定义后处理逻辑。\n\n\nuniforms\nObject（可选）\n传入 shader 的 uniform 参数，可以是常数、函数或者 Cesium 的回调函数。\n\n\ntextureScale\nNumber（可选）\n用于降低处理图像的分辨率（节省性能），1 表示全分辨率。\n\n\nsampleMode\nCesium.PostProcessStageSampleMode（可选）\n默认是 NEAREST。可设为 LINEAR 实现更平滑的采样。\n\n\n6 Cesium.Primitive()图元表示 中的几何体Scene。几何体可以来自单个GeometryInstance （如下面的示例 1 所示），也可以来自实例数组，即使几何体来自不同的几何类型，例如，一个RectangleGeometry和一个EllipsoidGeometry（如代码示例 2 所示）。\n基元将几何体实例与Appearance描述完整着色（包括 Material和 ）的 组合在一起RenderState。粗略地说，几何体实例定义了结构和位置，而外观定义了视觉特性。将几何体和外观解耦使我们能够混合搭配大多数几何体，并独立地添加新的几何体或外观。\n将多个实例组合成一个基元称为批处理，这可以显著提高静态数据的性能。可以单独挑选实例；Scene#pick返回它们的GeometryInstance#id。使用类似 的实例外观PerInstanceColorAppearance，每个实例还可以拥有独特的颜色。\nGeometry可以在 Web Worker 或主线程上创建和批处理。前两个示例展示了如何在 Web Worker 上使用几何体描述创建几何体。第三个示例展示了如何通过显式调用createGeometry方法在主线程上创建几何体。\n\n\n\n名称\n类型\n默认值\n描述\n\n\n\ngeometryInstances\nGeometryInstance[] | GeometryInstance\n—\n选填，要渲染的几何实例（或单个几何实例）。\n\n\nappearance\nAppearance\n—\n选填，用于渲染图元的外观。\n\n\ndepthFailAppearance\nAppearance\n—\n选填，当深度测试失败时，用于遮蔽该图元的外观。\n\n\nshow\nBoolean\ntrue\n选填，是否显示该图元。\n\n\nmodelMatrix\nMatrix4\nMatrix4.IDENTITY\n选填，将图元（所有几何实例）从模型变换到世界坐标的 4x4 变换矩阵。\n\n\nvertexCacheOptimize\nBoolean\nfalse\n选填，当为 true 时，几何顶点针对前后顶点着色器缓存进行优化。\n\n\ninterleave\nBoolean\nfalse\n选填，当为 true 时，几何顶点属性交错排列，可略微提升渲染性能但增加加载时间。\n\n\ncompressVertices\nBoolean\ntrue\n选填，当为 true 时，几何顶点被压缩以节省内存。\n\n\nreleaseGeometryInstances\nBoolean\ntrue\n选填，当为 true 时，原语不保留对输入 geometryInstances 的引用以节省内存。\n\n\nallowPicking\nBoolean\ntrue\n选填，当为 true 时，每个几何实例可通过 Scene#pick 拾取；为 false 时可节省 GPU 内存。\n\n\ncull\nBoolean\ntrue\n选填，当为 true 时，渲染器视锥会根据图元的边界体积进行剔除；若你手动剔除图元，可设为 false 提升性能。\n\n\nasynchronous\nBoolean\ntrue\n选填，确定是否异步创建原语或阻塞直到准备好。\n\n\ndebugShowBoundingVolume\nBoolean\nfalse\n选填，仅用于调试。是否显示此图元命令的边界球。\n\n\nshadows\nShadowMode\nShadowMode.DISABLED\n选填，确定该图元是否投射或接收来自光源的阴影。\n\n\n// 1. Draw a translucent ellipse on the surface with a checkerboard patternconst instance = new Cesium.GeometryInstance(&#123;  geometry : new Cesium.EllipseGeometry(&#123;      center : Cesium.Cartesian3.fromDegrees(-100.0, 20.0),      semiMinorAxis : 500000.0,      semiMajorAxis : 1000000.0,      rotation : Cesium.Math.PI_OVER_FOUR,      vertexFormat : Cesium.VertexFormat.POSITION_AND_ST  &#125;),  id : &#x27;object returned when this instance is picked and to get/set per-instance attributes&#x27;&#125;);scene.primitives.add(new Cesium.Primitive(&#123;  geometryInstances : instance,  appearance : new Cesium.EllipsoidSurfaceAppearance(&#123;    material : Cesium.Material.fromType(&#x27;Checkerboard&#x27;)  &#125;)&#125;));\n\n// 2. Draw different instances each with a unique colorconst rectangleInstance = new Cesium.GeometryInstance(&#123;  geometry : new Cesium.RectangleGeometry(&#123;    rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0),    vertexFormat : Cesium.PerInstanceColorAppearance.VERTEX_FORMAT  &#125;),  id : &#x27;rectangle&#x27;,  attributes : &#123;    color : new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5)  &#125;&#125;);const ellipsoidInstance = new Cesium.GeometryInstance(&#123;  geometry : new Cesium.EllipsoidGeometry(&#123;    radii : new Cesium.Cartesian3(500000.0, 500000.0, 1000000.0),    vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL  &#125;),  modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(    Cesium.Cartesian3.fromDegrees(-95.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 500000.0), new Cesium.Matrix4()),  id : &#x27;ellipsoid&#x27;,  attributes : &#123;    color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)  &#125;&#125;);scene.primitives.add(new Cesium.Primitive(&#123;  geometryInstances : [rectangleInstance, ellipsoidInstance],  appearance : new Cesium.PerInstanceColorAppearance()&#125;));\n\n"},{"title":"LeetCode100","url":"/post/8ec8235e.html","content":"1 两数之和给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。\n你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。\n你可以按任意顺序返回答案。\n示例 1：\n输入：nums = [2,7,11,15], target = 9输出：[0,1]解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。\n\n示例 2：\n输入：nums = [3,2,4], target = 6输出：[1,2]\n\n示例 3：\n输入：nums = [3,3], target = 6输出：[0,1]\n\n方法一：暴力破解\nvar twoSum = function(nums, target) &#123;    for (let i = 0; i &lt; nums.length - 1; i++) &#123;        for (let j = i + 1; j &lt; nums.length; j++) &#123;            if (nums[i] + nums[j] === target) &#123;                return [i, j];            &#125;        &#125;    &#125;&#125;;\n\n方法二：哈希表\nvar twoSum = function(nums, target) &#123;    const map = new Map()    for (let i = 0; i &lt; nums.length; i++) &#123;        if (map.has(target - nums[i])) &#123;            return [map.get(target - nums[i]), i]        &#125;        map.set(nums[i], i)    &#125;    return []&#125;;\n\n2 字母异位分组给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表。\n示例 1:\n输入: strs &#x3D; [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]\n输出: [[“bat”],[“nat”,”tan”],[“ate”,”eat”,”tea”]]\n解释：\n\n在 strs 中没有字符串可以通过重新排列来形成 &quot;bat&quot;。\n字符串 &quot;nat&quot; 和 &quot;tan&quot; 是字母异位词，因为它们可以重新排列以形成彼此。\n字符串 &quot;ate&quot; ，&quot;eat&quot; 和 &quot;tea&quot; 是字母异位词，因为它们可以重新排列以形成彼此。\n\n示例 2:\n输入: \nstrs = [&quot;&quot;]\n\n输出: \n[[&quot;&quot;]]\n\n示例 3:\n输入: \nstrs = [&quot;a&quot;]\n\n输出:\n[[&quot;a&quot;]]\n\n方法一：哈希匹配\nvar groupAnagrams = function(strs) &#123;    const map = new Map();    for(let s of strs)&#123;        const count= new Array(26).fill(0);        for(let ch of s)&#123;            //统计每个字母出现的次数            count[ch.charCodeAt(0)-97]++;        &#125;        //使用频次作为唯一键        const key=count.join(&#x27;#&#x27;)        if(!map.has(key))&#123;            map.set(key,[])        &#125;        map.get(key).push(s);    &#125;    return Array.from(map.values());&#125;;\n\n总结一下：\n\n这道题利用哈希生成唯一键进行数组匹配，下面是伪代码\nconst key= count.join(&quot;#&quot;)if(!map.has(key))&#123;   map.set(key,[])&#125;//得到key对应的valuemap.get(key).push(s)\n\n具体思路：\n\n\n1、先创建一个Map集合（键为String类型，值为List类型）2、对字符数组strs进行增强for循环遍历，得到临时变量str（即每次按顺序遍历到的字符数组中的元素）3、把每次遍历到的str（此时是字符串整体）变成单个的字符存储到array中4、对array中的单个字符进行升序排列5、把升序排列后的array里面的单个字符再变回字符串存储到key中6、对map集合进行查找，如果map集合中存在key里面的字符串，就把这个键对应的值（List）返回；如果不存在，就返回一个空集合new ArrayList() ，返回后的东西（是个集合）就是 list7、把遍历到的str存到 list中8、更新map里的键值对，键为经过排序后存到key中的字符串；值为 list9、返回map集合中所有的值的集合 list\n方法二：排序 思想与上面类似，创建唯一键\nvar groupAnagrams = function(strs) &#123;    const map = new Object();    for (let s of strs) &#123;        const count = new Array(26).fill(0);        for (let c of s) &#123;            count[c.charCodeAt() - &#x27;a&#x27;.charCodeAt()]++;        &#125;        map[count] ? map[count].push(s) : map[count] = [s];    &#125;    return Object.values(map);&#125;;\n\n"},{"title":"webgl","url":"/post/a4c303ae.html","content":"1.1webgl学习\nfunction initShader(gl, vertexShaderSource, fragmentShaderSource) &#123;    //创建顶点着色器对象    const vertexShader = gl.createShader(gl.VERTEX_SHADER);    //创建片元着色器对象    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);    //引入顶点、片元着色器源代码    gl.shaderSource(vertexShader, vertexShaderSource);    gl.shaderSource(fragmentShader, fragmentShaderSource);    //编译顶点、片元着色器    gl.compileShader(vertexShader);    gl.compileShader(fragmentShader);    //创建程序对象program    const program = gl.createProgram();    //附着顶点着色器和片元着色器到program    gl.attachShader(program, vertexShader);    gl.attachShader(program, fragmentShader);    //链接program    gl.linkProgram(program);    //使用program    gl.useProgram(program);    //返回程序program对象    return program;&#125;\n\n\n"},{"title":"VUE","url":"/post/560a971e.html","content":""},{"title":"高光谱遥感","url":"/post/aa9b66de.html","content":"基本信息文件名称GF5A_AHSI_E87.1_N46.1_20250309_011971_L10000236405\n\n卫星ID: GF5A  \n传感器ID: AHSI  \n场景ID: 237283  \n产品ID: 236405  \n轨道ID: 11971  \n接收站: KSC  \n产品级别: LEVEL1  \n产品格式: GeoTiff  \n任务类型: Normal\n\n光谱信息\n波段数: 330  \n波段范围: 1–150, 151–330\n\n轨道与姿态数据\n轨道&#x2F;路径行号: Path 365 &#x2F; Row 633  \n轨道数据: GPS  \n姿态数据: PATT  \n高程数据: DEM  \n姿态角:  \n滚转角（Roll）: -0.002286°  \n俯仰角（Pitch）: 0.000984°  \n偏航角（Yaw）: -2.660247°\n\n\n\n太阳与卫星观测角度\n太阳方位角: 190.53°  \n太阳天顶角: 50.95°  \n卫星方位角: 191.52°  \n卫星天顶角: 0.04°\n\n成像信息\n成像时间:  \n开始: 2025-03-09 06:54:33  \n结束: 2025-03-09 06:54:42\n\n\n空间分辨率 (GSD): 30 m  \n图像尺寸: 2053 × 2015 像素  \n增益模式: 1.50507, 2.21484  \n积分时间: 4400 μs  \n辐射定标参数时间: 2023-04-20  \n光谱定标参数时间: 2022-12-01  \nOGP缩放因子: 10000  \n地日距离: 0.992964 AU  \n重采样方法: BL  \n去噪方式: NONE\n\n地理信息\n中心点: (46.077532°N, 87.144474°E)  \n四角坐标:  \n左上: (45.874242°N, 87.623497°E)  \n右上: (45.738283°N, 86.866348°E)  \n右下: (46.280395°N, 86.661815°E)  \n左下: (46.417207°N, 87.426234°E)\n\n\n\n质量与生产信息\n云量: 4%  \nDDS标志: TRUE  \n产品生产时间: 2025-03-09 18:25:08  \n软件版本: 1.0.0\n\n"}]